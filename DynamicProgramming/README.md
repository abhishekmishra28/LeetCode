# Dynamic Programming (DP) Problems

This folder contains problems based on **Dynamic Programming** â€” one of the most
powerful techniques in algorithm design. DP helps solve problems that involve
overlapping subproblems, optimal decisions, and recursion with memory.

---

## ğŸ¯ What youâ€™ll practice here

- Breaking problems into subproblems  
- Identifying overlapping subproblems  
- Using memoization (top-down DP)  
- Using tabulation (bottom-up DP)  
- Converting recursion to iteration  
- Optimizing space and time  
- Recognizing patterns behind DP problems

---

## ğŸ§© Common patterns in this folder

- Fibonacci / basic recursion to DP  
- 0/1 Knapsack & variations  
- Subset / Partition problems  
- Longest Increasing Subsequence  
- Longest Common Subsequence  
- Coin Change / Unbounded Knapsack  
- Grid paths & obstacles  
- DP on strings  
- DP on trees  
- Bitmask DP (advanced)

---

## ğŸ“ Format for each problem

Each problem includes:

1. **Problem summary**
2. **Intuition â€” why DP is needed**
3. **State definition (dp[i], dp[i][j], etc.)**
4. **Transition explanation**
5. **Complexity analysis**
6. **Code implementation**

---

## ğŸ“Œ Examples you may see here

- Climbing Stairs  
- House Robber  
- Coin Change  
- Partition Equal Subset Sum  
- Longest Increasing Subsequence  
- Edit Distance  
- Longest Common Subsequence  
- Unique Paths  
- Knapsack variations  

---

Dynamic Programming builds strong logical thinking and pattern recognition.
Once you learn to identify *states* and *transitions*, many tough problems
become intuitive.

Keep practicing â€” DP rewards consistency! ğŸš€
